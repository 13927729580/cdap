apply plugin: 'continuuity'

buildscript {
  apply from: 'continuuity.gradle'
}


/**
 * Specify all the dependencies
 */
dependencies {

    // Internal dependencies.
//    if(multiModule && ! buildingRelease)
//    {
//        compile project(":common")
//        compile project(":gateway")
//        compile project(":overlord")
//        compile fileTree(dir: '../flow/build/libs', excludes:['**/*source*', '**/*javadoc**'])
//        compile fileTree(dir: '../data-fabric/build/libs', excludes:['**/*source*', '**/*javadoc**'])
//    }
//    else
//    {
        //runtime group: 'com.continuuity', name: 'common', version: "${version}", changing: true
        //runtime group: 'com.continuuity', name: 'data-fabric', version: "${version}", changing: true
        //runtime group: 'com.continuuity', name: 'flow', version: "${version}", changing: true
        //runtime group: 'com.continuuity', name: 'gateway', version: "${version}", changing: true
        //runtime group: 'com.continuuity', name: 'overlord', version: "${version}", changing: true
//    }
}

evaluationDependsOn(':singlenode')
evaluationDependsOn(':test')

if(! multiModule) {
    throw new InvalidUserDataException("Invalid invocation: This is strictly a multimodule build at the moment.  Please checkout the 'continuuity' project and build from there.")
}
if(! project.hasProperty('releaseVersion')) {
    throw new InvalidUserDataException("Could not find releaseVersion property.  It should be specified in :distributions/gradle.properties")
} 

gradle.taskGraph.whenReady {taskGraph ->
    if (taskGraph.hasTask(cloud_dist)) {
        dependencies {
            runtime group: 'com.continuuity', name: 'performance', version: "${version}", changing: true
        }
    }
}

task javadoc(type: Javadoc, overwrite: true) {
    group = 'Documentation' 
    description = 'Aggregates API javadocs across all projects.'
    source project.parent.subprojects.collect { project ->
	project.sourceSets.api.allJava
    }
    destinationDir = new File(buildDir, 'javadoc') 
    // Might need a classpath
    classpath = files(project.parent.subprojects.collect { project ->
	project.sourceSets.main.compileClasspath
    })
}


task singlenode_stage_conf (type: Copy) {
    from project(':singlenode').tasks.getByName('stageConfSingleNode').outputs
    into "${buildDir}/singlenode/conf" 
}

task singlenode_stage_lib (type: Copy) {
    //from project(':singlenode').configurations.getByName('compile')
    from project(':singlenode').configurations.getByName('runtime')
    from project(':singlenode').tasks.getByName('jar').outputs
    from project(':test').tasks.getByName('testJar').outputs
    into "${buildDir}/singlenode/lib"
}

import org.apache.tools.ant.filters.ReplaceTokens

task singlenode_stage_bin (type: Copy) {
    // include generated startscripts
    from project(':singlenode').tasks.getByName('startScripts').outputs
    // include project bin directories
    from project.parent.subprojects.collect { project ->
        project.file('bin')
    }
    into "${buildDir}/singlenode/bin" 
    exclude 'node'
    exclude 'far-server'
    exclude 'run-java'
    exclude 'flow-config.sh'
    exclude 'flow-client'
    exclude 'service'
    exclude 'dfbench'
    exclude 'common*'
    def cp = project(':singlenode').tasks.getByName('startScripts').classpath.collect { "\$APP_HOME/lib/${it.name}" }.join(':')
    cp += ":\$APP_HOME/conf/"
    filter(ReplaceTokens, tokens: [classpath: cp])
}

task singlenode_stage_docs_api (type: Copy) {
    from javadoc.outputs 
    into "${buildDir}/singlenode/docs/api"
}

task singlenode_stage_examples (type: Copy) {
    from project(':singlenode').tasks.getByName('copyExamples').outputs 
    into "${buildDir}/singlenode/examples" 
}

task singlenode_stage_root (type: Copy) {
    from project(':singlenode').tasks.getByName('createApiJar').outputs
    from project(':singlenode').tasks.getByName('createApiSourceJar').outputs
    from project(':singlenode').tasks.getByName('createApiJavadocJar').outputs
    from project(':singlenode').files('src/dist')
    into "${buildDir}/singlenode"
}


// these should be build tasks in webapp
task singlenode_stage_web_client (type: Copy, dependsOn: ':web-cloud-app:build') {
    from project(':web-cloud-app').file('build/developer/client')
    into "${buildDir}/singlenode/web-app/client" 
}

task singlenode_stage_web_server (type: Copy, dependsOn: ':web-cloud-app:build') {
    from project(':web-cloud-app').file('build/developer/server')
    into "${buildDir}/singlenode/web-app/server" 
}

task singlenode_dist (type: Zip) {
    group = 'Continuuity'
    description = 'Generates the singlenode distribution zip file'

    baseName = "continuuity"
    appendix = "developer-edition"
    version = releaseVersion
    classifier = "beta"

    from "${buildDir}/singlenode"
    into "${baseName}-${appendix}-${version}-${classifier}"

}
    
singlenode_dist.dependsOn {
    tasks.findAll { task -> task.name.startsWith('singlenode_stage_') }
}

//tasks.findAll { task -> task.name.startsWith('singlenode_stage_') }.each {
//    it.dependsOn clean
//}



/**
 * Cloud distribution
 */

task cloud_stage_lib (type: Copy) {

    // assuming dependencies are same as singlenode.  cant aggregate across
    // subprojects because it results in multiple versions of same jar
    from project(':singlenode').configurations.getByName('runtime')
    // performance jar only goes in cloud_dist
    from project.configurations.getByName('runtime')
    into "${buildDir}/cloud/lib"

}

task cloud_stage_bin (type: Copy) {

    from project.parent.subprojects.collect { project ->
        project.file('bin')
    }
    into "${buildDir}/cloud/bin"
    exclude 'node'
    def cp = "\$CONTINUUITY_HOME/lib/*:\$CONTINUUITY_HOME/conf/"
    filter(ReplaceTokens, tokens: [classpath: cp])

}


task cloud_stage_envconf (type: Copy) {

    from project.parent.subprojects.collect { project ->
        // include [service]-env.sh
        project.file('conf')

    }
    include "*-env.sh"
    into "${buildDir}/cloud/conf"
}

// these should be build tasks in webapp
task cloud_stage_web_client (type: Copy, dependsOn: ':web-cloud-app:build') {
    from project(':web-cloud-app').file('build/developer/client')
    into "${buildDir}/cloud/web-app/client"
}

task cloud_stage_web_server (type: Copy, dependsOn: ':web-cloud-app:build') {
    from project(':web-cloud-app').file('build/developer/server')
    into "${buildDir}/cloud/web-app/server"
}

task cloud_stage_log {
    //create/include empty log directory 
    ext.logDir = new File("${buildDir}/cloud/logs")
    doLast {
        ext.logDir.mkdirs()
    }
}


task cloud_dist (type: Tar) {
    group = 'Continuuity'
    description = 'Generates the distribution tar file for the cloud'

    // set compression method
    compression = Compression.GZIP

    baseName = "continuuity"
    appendix = "cloud"
    version = releaseVersion
    if( project.hasProperty('teamcityBuildNumber')) {
        classifier = teamcityBuildNumber
    } else {
        classifier = ""
    }

    from "${buildDir}/cloud"
    into "${baseName}-${appendix}-${version}"
}
cloud_dist.dependsOn {
    tasks.findAll { task -> task.name.startsWith('cloud_stage_') }
}


task build (overwrite: true) {
    doLast {
        println "overwriting :distributions:build as No-Op task for CI build"
    }
}

// upload and archive distribution zip and rotate symlink to always point to the latest
task upload_cloud_dist (dependsOn: cloud_dist) {
    group = 'Distribution'
    description = 'creates/archives distribution zip to configured target server'

    doLast {
        // first make sure destination 'incoming' dir exists
        ant.sshexec(host: 'staging.continuuity.com',
        username: 'deploy',
        keyfile: "$System.env.HOME/.ssh/deploy_key",
        trust: 'true',
        verbose: 'true',
        failonerror: 'true',
        command: "mkdir -p distributions/${cloud_dist.baseName}/incoming")

        // upload to incoming dir
        println "uploading ${cloud_dist.archiveName} to staging.continuuity.com using key $System.env.HOME/.ssh/deploy_key"
        ant.scp(file: cloud_dist.archivePath, toDir: "deploy@staging.continuuity.com:~/distributions/${cloud_dist.baseName}/incoming", keyfile: "$System.env.HOME/.ssh/deploy_key")

        // construct cmd to move uploaded zip to /YYYY/mm/dd/, and symlink to it (replacing any previous symlinks)
        ext.archive_cmd = 'cd distributions && YEAR=`date +%Y` && MONTH=`date +%m` && DAY=`date +%d`' + " && mkdir -p ${cloud_dist.baseName}" + '/$YEAR/$MONTH/$DAY'
        ext.archive_cmd += ' && mv --backup --suffix=$(date +-%H:%M:%S)' + " ${cloud_dist.baseName}/incoming/"
        ext.archive_cmd += "${cloud_dist.archiveName} ${cloud_dist.baseName}" + '/$YEAR/$MONTH/$DAY/.'
        ext.archive_cmd += ' && ln -s $YEAR/$MONTH/$DAY/' + "${cloud_dist.archiveName} ${cloud_dist.baseName}" + '/latest.zip.new'
        ext.archive_cmd += " && mv -Tf ${cloud_dist.baseName}/latest.zip.new"
        ext.archive_cmd += " ${cloud_dist.baseName}/${cloud_dist.baseName}-${cloud_dist.appendix}-${cloud_dist.version}.${cloud_dist.extension}"
        println ext.archive_cmd

        // sshexec the archiving cmd
        ant.sshexec(host: 'staging.continuuity.com',
        username: 'deploy',
        keyfile: "$System.env.HOME/.ssh/deploy_key",
        trust: 'true',
        verbose: 'true',
        failonerror: 'true',
        command: ext.archive_cmd)
    }
}

