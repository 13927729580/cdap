package com.continuuity.data2.transaction.queue;

import com.continuuity.common.queue.QueueName;
import com.continuuity.data.operation.ttqueue.QueueEntry;
import com.continuuity.data2.transaction.Transaction;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Producer for an in-memory queue.
 */
public class InMemoryQueue2Producer extends AbstractQueue2Producer {

  private final InMemoryQueue queue;
  private final BlockingQueue<QueueEntry> toEnqueue = new LinkedBlockingQueue<QueueEntry>();
  private Transaction currentTx = null;
  private boolean committed = false;
  private int lastEnqueueCount;

  public InMemoryQueue2Producer(QueueName queueName, InMemoryQueueService queueService, QueueMetrics queueMetrics) {
    super(queueMetrics);
    this.queue = queueService.getQueue(queueName);
  }

  @Override
  public void enqueue(QueueEntry entry) throws IOException {
    if (committed) {
      throw new RuntimeException("enqueue called after commit. ");
    }
    toEnqueue.add(entry);
  }

  @Override
  public void enqueue(Iterable<QueueEntry> entries) throws IOException {
    if (committed) {
      throw new RuntimeException("enqueue called after commit. ");
    }
    Iterables.addAll(toEnqueue, entries);
  }

  @Override
  public void startTx(Transaction tx) {
    currentTx = tx;
    toEnqueue.clear();
    committed = false;
  }

  @Override
  public Collection<byte[]> getTxChanges() {
    return ImmutableList.of(); // no conflicts generated by queues
  }

  @Override
  public boolean commitTx() throws Exception {
    if (committed) {
      throw new RuntimeException("commit called again after commit. ");
    }
    List<QueueEntry> entries = Lists.newArrayListWithCapacity(toEnqueue.size());
    toEnqueue.drainTo(entries);
    int seqId = 0;
    for (QueueEntry entry : entries) {
      queue.enqueue(currentTx.getWritePointer(), seqId++, entry);
    }
    committed = true;
    lastEnqueueCount = entries.size();
    return true;
  }

  @Override
  protected int getLastEnqueueCount() {
    return lastEnqueueCount;
  }

  @Override
  public boolean rollbackTx() throws Exception {
    if (committed) {
      for (int seqId = 0; seqId < lastEnqueueCount; seqId++) {
        queue.undoEnqueue(currentTx.getWritePointer(), seqId);
      }
    }
    return true;
  }
}
