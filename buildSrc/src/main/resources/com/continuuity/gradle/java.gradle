// The contents of this file applies to all subprojects.
apply plugin: 'java'

/// Define common dependencies.
dependencies {
    compile "org.slf4j:slf4j-api:1.6.4"
    compile "ch.qos.logback:logback-core:1.0.+"
    compile "ch.qos.logback:logback-classic:1.0.+"
    compile "org.codehaus.groovy:groovy-all:1.8.+"
    compile "com.google.inject:guice:3.0-rc3"

    testCompile "org.mockito:mockito-core:1.9.+"
    testCompile "junit:junit:4.+"
}

configurations {
    // ENG-336 - Exclude slf4j-log4j12 from all projects.
    all*.exclude group: 'org.slf4j', module: 'slf4j-log4j12'
}

// Write out some useful information when tests run
test {
    beforeTest { descriptor ->
        logger.lifecycle("Running " + descriptor)
    }
}

/**
 * Creates source jar
 */
task sourcesJar(type: Jar, dependsOn:classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

/**
 * Creates javadoc jar
 */
task javadocJar(type: Jar, dependsOn:javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

// generate the API jar

sourceSets {
  api
}

task apiJar(type: Jar) {
  from sourceSets.api.output
  classifier = "api"
}

task apiJavadoc(type: Javadoc, dependsOn:apiJar) {
  source sourceSets.api.allJava
  destinationDir = reporting.file("${buildDir}/api-docs")
}

task apiJavadocJar(type: Jar, dependsOn:apiJavadoc) {
  classifier = "api-javadoc"
  from apiJavadoc.destinationDir
}

/**
 * Builds jar, source and docs
 */
artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
}

/**
 * Automagically generates the classpath that can be *ONLY* used during development.
 * A file named 'generated-classpath' is added to project/build directory.
 */
task classpathGenerator << {

    def classpath = null

    if (project.hasProperty('multiModule'))  {
        classpath = new File(project.projectDir.toString() + '/build/generated-classpath')
    } else {
        classpath = new File('build/generated-classpath')
    }

    configurations.compile.each { File file ->  classpath.append(file.toString() + ':') }
}

build.dependsOn classpathGenerator

/**
 * Determine if the release task was specified and set the release flag.
 *
 * This should result in projects building in "standalone" mode, pulling in dependent jars from artifactory
 */
if (gradle.startParameter.getTaskNames().contains('release')) {
    getProject().extensions.getExtraProperties().set("buildingRelease", true);
} 

/**
 * Create Release TAR ball
 * To create distribution for each component - run gradle release
 */
task release (type:  Tar, dependsOn: jar)  {
    group = 'Continuuity'
    description = 'Generates distribution tar file.'

    /** Set the compression to gzip */
    compression = Compression.GZIP

    /** Copy everything from bin into project/bin */
    from('bin') {
        into("${project.name}-${project.version}/bin")
    }

    /** Copy everything from conf into project/conf */
    from('conf') {
        into("${project.name}-${project.version}/conf")
    }

    /** Copy everything from src/main/resources into project/conf */
    into("${project.name}-${project.version}/conf") {
        from sourceSets.main.output.resourcesDir
    }

    /** Add the project package itself and all it's dependencies. */
    into("${project.name}-${project.version}/libs") {
      from configurations.runtime
      from jar.archivePath
    }

    /** Load all the dependencies into the libs directory. */
    if(project.hasProperty('multiModule')) {
      into("${project.name}-${project.version}/libs") {
        from project(":data-fabric").artifacts
        from project(":flow").artifacts
        from project(":common").artifacts
      }
    }
}

/**
 * Upload Release TAR ball to staging.continuuity.com
 *
 */
// configurations/dependencies required for ant scp/ssh tasks
configurations {
    antssh
}
dependencies {
    antssh group: 'org.apache.ant', name: 'ant-jsch', version: '1.8.2'
}

// add the additional jar to the AntBuilder classpath for use with the ant tasks
ClassLoader antClassLoader = org.apache.tools.ant.Project.class.classLoader
configurations.antssh.each { File f ->
    antClassLoader.addURL(f.toURI().toURL())
}

// scp distribution zip to destination staging.continuuity.com
task upload_release (dependsOn: release) << {

    // first make sure destination 'incoming' dir exists
    ant.sshexec(host: 'staging.continuuity.com',
    username: 'deploy',
    keyfile: "$System.env.HOME/.ssh/deploy_key",
    trust: 'true',
    verbose: 'true',
    failonerror: 'true',
    command: "mkdir -p distributions/${release.baseName}/incoming")

    println "uploading ${release.archiveName} to staging.continuuity.com using key $System.env.HOME/.ssh/deploy_key"
    ant.scp(file: release.archivePath, toDir: "deploy@staging.continuuity.com:~/distributions/${release.baseName}/incoming", keyfile: "$System.env.HOME/.ssh/deploy_key")
}

// archive uploaded distribution zip and rotate symlink to always point to the latest
task distro (dependsOn: upload_release) {
    group = 'Distribution'
    description = 'creates/archives distribution zip to configured target server'
    doLast {
        //move uploaded zip to /YYYY/mm/dd/, and symlink to it (replacing any previous symlinks)
        ext.archive_cmd = 'cd distributions && YEAR=`date +%Y` && MONTH=`date +%m` && DAY=`date +%d`' + " && mkdir -p ${release.baseName}" + '/$YEAR/$MONTH/$DAY'
        ext.archive_cmd += ' && mv --backup --suffix=$(date +-%H:%M:%S)' + " ${release.baseName}/incoming/" + "${release.archiveName} ${release.baseName}" + '/$YEAR/$MONTH/$DAY/.'
        ext.archive_cmd += ' && ln -s $YEAR/$MONTH/$DAY/' + "${release.archiveName} ${release.baseName}" + '/latest.zip.new'
        ext.archive_cmd += " && mv -Tf ${release.baseName}/latest.zip.new ${release.baseName}/${release.archiveName}"

        println ext.archive_cmd

        ant.sshexec(host: 'staging.continuuity.com',
        username: 'deploy',
        keyfile: "$System.env.HOME/.ssh/deploy_key",
        trust: 'true',
        verbose: 'true',
        failonerror: 'true',
        command: ext.archive_cmd)
    }
}

