apply plugin: 'continuuity'

apply plugin: 'application'
mainClassName = 'com.continuuity.SingleNodeMain'


buildscript {
  apply from: 'continuuity.gradle'
}

/**
 * Specify all the dependencies
 */
dependencies {

    // for singlenode - simulate standalone project
    multiModule = 0

    /// Internal dependencies.
    if(multiModule)
    {
        compile project(":common")
        compile project(":gateway")
        compile project(":flow")
        compile project(":data-fabric")
        compile project(":overlord")
        runtime group: 'com.continuuity', name: 'flow', classifier: 'api', version: '0.1.0-SNAPSHOT'
        runtime group: 'com.continuuity', name: 'data-fabric', classifier: 'api', version: '0.1.0-SNAPSHOT'
    }
    else
    {
        compile group: 'com.continuuity', name: 'common', version: '0.1.0-SNAPSHOT'
        compile group: 'com.continuuity', name: 'data-fabric', version: '0.1.0-SNAPSHOT'
        compile group: 'com.continuuity', name: 'flow', version: '0.1.0-SNAPSHOT'
        compile group: 'com.continuuity', name: 'gateway', version: '0.1.0-SNAPSHOT'
        compile group: 'com.continuuity', name: 'overlord', version: '0.1.0-SNAPSHOT'
    }

    testCompile group: 'junit', name: 'junit', version: '4.+'
    testCompile group: 'org.mockito', name: 'mockito-core', version: '1.9.+'
}

/**
 * Exclude any config xml from singlenode jar
 */
jar.exclude '*.xml'


task javadoc(type: Javadoc, overwrite: true) {
    group = 'Documentation' 
    description = 'Aggregates API javadocs across all projects.'
    source project.parent.subprojects.collect { project ->
        project.sourceSets.api.allJava
    }
    destinationDir = new File(buildDir, 'javadoc')
    // Might need a classpath
    classpath = files(project.parent.subprojects.collect { project ->
        project.sourceSets.main.compileClasspath
    })
}

/**
 * Configure distZip task 
 */
tasks.distZip {
    baseName = "bigFlow"
    appendix = "singlenode"
    version = ""
    classifier = ""
}

distZip.dependsOn javadoc
distZip.dependsOn ':web-cloud-app:build'



// dynamically generate "stageConf-[project]" tasks
project.parent.subprojects.each { p ->
    //println "    name: ${p.name}"
    if (p.sourceSets.main.output.resourcesDir.isDirectory()) {
        //println "    resourceDir: ${p.sourceSets.main.output.resourcesDir}"
        if (p != project) { //exclude self (singlenode)
            println "staging conf for ${p.name}"
            task "genstageConf${p.name}" (type: Copy) {
                from "${project(":${p.name}").sourceSets.main.output.resourcesDir}"
                include 'continuuity-default.xml'
                include 'continuuity-flow.xml'
                into "${buildDir}/conf"
                rename { "continuuity-${p.name}.xml" }
            }
        }
    } else {
        println "skipping conf for ${p.name} - no resources dir"
    }
}

// conf/ - copy singlenode conf into a staging dir
task stageConfSingleNode (type: Copy) {
    println "staging conf for singlenode"
    from "${sourceSets.main.output.resourcesDir}"
    include 'continuuity-webapp.xml'
    include 'logback.xml'
    into "${buildDir}/conf"
    //fix path for web=app
    doLast {
        def webConfFile = file "${buildDir}/conf/continuuity-webapp.xml"
        webConfFile.text = webConfFile.text.replaceFirst('../web-cloud-app/build/server/main.js','web-app/server/main.js')
    }
}

stageConfSingleNode.dependsOn {
    tasks.findAll { task -> task.name.startsWith('genstageConf') }
}


/*
task stageConfGateway (type: Copy) {
    from "${project(':gateway').sourceSets.main.output.resourcesDir}"
    include 'continuuity-default.xml'
    into "${buildDir}/conf"
    rename { 'continuuity-gateway.xml' }
}
task stageConfFlow (type: Copy) {
    from "${project(':flow').sourceSets.main.output.resourcesDir}"
    include 'continuuity-default.xml'
    into "${buildDir}/conf"
    rename { 'continuuity-flow.xml' }
}
*/


//distZip.dependsOn stageConfSingleNode, stageConfGateway, stageConfFlow
distZip.dependsOn stageConfSingleNode

// conf/ - include staging conf dir (incl token-replaced files) in distZip
applicationDistribution.from("$buildDir/conf") {
    into "conf"
}

//conf editing: fix path for web-app
//tasks.stageConfSingleNode {
//    doLast {
//        def webConfFile = file "${buildDir}/conf/continuuity-webapp.xml"
//        webConfFile.text = webConfFile.text.replaceFirst('../web-cloud-app/build/server/main.js','web-app/server/main.js')
//    }
//}



   
applicationDistribution.from("$buildDir/javadoc") {
    into "docs"
}

//web-cloud-app
applicationDistribution.from(project(':web-cloud-app').file('build/client')) {
    into "web-app/client"
}

applicationDistribution.from(project(':web-cloud-app').file('build/server')) {
    into "web-app/server"
}


/**
 * Hack the start script  - set application name, remain in $APP_HOME and add $APP_HOME/conf/ to classpath
 */

tasks.startScripts {
    applicationName = "bigFlow"
    doLast {
        def scriptFile = file "${outputDir}/${applicationName}"
        scriptFile.text = scriptFile.text.replace('cd "$SAVED"', '')
        scriptFile.text = scriptFile.text.replaceFirst('CLASSPATH=(.*)', 'CLASSPATH=$1:\\$APP_HOME/conf/')
        //for windows .bat - yes, apparently backslash must be triple-escaped
        def scriptFileWin = file "${outputDir}/${applicationName}.bat"
        scriptFileWin.text = scriptFileWin.text.replaceFirst('set CLASSPATH=(.*)', 'set CLASSPATH=$1;%APP_HOME%\\\\conf\\\\')
    }
}

/**
 * Collect bin scripts from gateway project and replace @classpath@ token
 */

import org.apache.tools.ant.filters.ReplaceTokens

//applicationDistribution.from(project(':gateway').file('bin')) {
//    into "bin"
//    def cp = startScripts.classpath.collect { "\$APP_HOME/lib/${it.name}" }.join(':')
//    cp += ":\$APP_HOME/conf/"
//    filter(ReplaceTokens, tokens: [classpath: cp])
//}

//applicationDistribution.from(project(':gateway').file('bin')) {
//    into "bin"
//    def cp = startScripts.classpath.collect { "\$APP_HOME/lib/${it.name}" }.join(':')
//    cp += ":\$APP_HOME/conf/"
//    filter(ReplaceTokens, tokens: [classpath: cp])
//}


///**
// * Collect bin scripts from flow project and replace @classpath@ token
// */
//applicationDistribution.from(project(':flow').file('bin')) {
//    into "bin"
//    def cp = startScripts.classpath.collect { "\$APP_HOME/lib/${it.name}" }.join(':')
//    cp += ":\$APP_HOME/conf/"
//    filter(ReplaceTokens, tokens: [classpath: cp])
//}

/**
 * Collect bin scripts from data-fabric project and replace @classpath@ token
 */
//applicationDistribution.from(project(':data-fabric').file('bin')) {
//    into "bin"
//    def cp = startScripts.classpath.collect { "\$APP_HOME/lib/${it.name}" }.join(':')
//    cp += ":\$APP_HOME/conf/"
//    filter(ReplaceTokens, tokens: [classpath: cp])
//}


/**
 * Collect node start script from web-cloud-app project
 */
//applicationDistribution.from(project(':web-cloud-app').file('bin/start_webapp.sh')) {
//    into "bin"
//}

// dynamically generate "stageConf-[project]" tasks
project.parent.subprojects.each { p ->
    //println "    name: ${p.name}"
    if (p.file('bin').isDirectory()) {
        if (p != project) { //exclude self (singlenode)
            println "configuring bin for ${p.name}"
            applicationDistribution.from(project(":${p.name}").file('bin')) {
                into "bin"
                exclude 'node'
                def cp = startScripts.classpath.collect { "\$APP_HOME/lib/${it.name}" }.join(':')
                cp += ":\$APP_HOME/conf/"
                filter(ReplaceTokens, tokens: [classpath: cp])
            }
        }
    } else {
        println "skipping bin for ${p.name} - no bin dir"
    }
}
